seed=5;
rng(seed);
%seed=5
function G_eval = evaluate_discrete_tf(G0, omega)
    [n_outputs, n_inputs] = size(G0);
    G_eval = zeros(n_outputs, n_inputs);
    z = exp(1j * omega);
    for i = 1:n_outputs
        for j = 1:n_inputs
            b = G0{i, j}.b;
            a = G0{i, j}.a;
            num = sum(b .* (z .^ -(0:length(b)-1)));
            den = sum(a .* (z .^ -(0:length(a)-1)));
            G_eval(i, j) = num / den;
        end
    end
end

function y_time = simulate_plant_general_discrete(G0, u_time,sigma)
    [n_outputs, n_inputs] = size(G0);
    n_time_steps = size(u_time, 2);
    y_time = zeros(n_outputs, n_time_steps);

    for i = 1:n_outputs
        for j = 1:n_inputs
            if ~isempty(G0{i, j})
                b = G0{i, j}.b;
                a = G0{i, j}.a;
                response = filter(b, a, u_time(j, :)); %an~adir ruido acá
                y_time(i, :) = y_time(i, :) + response + sigma * randn(size(response));
            end
        end
    end
end

function G0 = generate_random_G0(n_outputs, n_inputs, n_states, seed)
    rng(seed); % Set seed for reproducibility

    % Generate a random discrete-time state-space system
    sysd = drss(n_states, n_outputs, n_inputs); % Already stable by design

    % Balance the realization to improve numerical properties
    sysd = balreal(sysd);

    % Convert to transfer function
    Gd_tf = tf(sysd);

    % Initialize the G0 cell structure
    G0 = cell(n_outputs, n_inputs);

    % Convert each transfer function entry to structured format
    for i = 1:n_outputs
        for j = 1:n_inputs
            % Extract numerator and denominator coefficients
            [b, a] = tfdata(Gd_tf(i, j), 'v');

            % Ensure denominator is nonzero
            if abs(a(1)) < 1e-12
                a(1) = 1e-12;
            end

            % Store in structured format
            G0{i, j} = struct('b', b, 'a', a);
        end
    end
end


% function G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed)
%     rng(seed);
%     % Generate a random discrete-time state-space system
%     sysd = drss(n_states, n_outputs, n_inputs); % No need to specify Ts
% 
%     % Convert the state-space system to a transfer function matrix
%     Gd_tf = tf(sysd);
% 
%     % Initialize the G0 cell structure
%     G0 = cell(n_outputs, n_inputs);
% 
%     % Convert each transfer function entry to your structure format
%     for i = 1:n_outputs
%         for j = 1:n_inputs
%             % Extract numerator and denominator coefficients
%             [b, a] = tfdata(Gd_tf(i, j), 'v');
% 
%             % Store in your structured format
%             G0{i, j} = struct('b', b, 'a', a);
% 
%             % Display the transfer function
%             % fprintf('G0(%d,%d):\n', i, j);
%             % fprintf('  Numerator (b): ');
%             % disp(b);
%             % fprintf('  Denominator (a): ');
%             % disp(a);
%             % fprintf('\n');
%         end
%     end
% end


function [mu_tilde, mu_bar, B_final, W_final] = power_method_convergence(G0, B_init, W_init, num_iters, r, mm, tol, tol2, N,sigma)
  
    freqs = 2 * pi * (0:N-1) / N;
    
    %[B_init, W_init] = initialize_bw_with_Dopt(G0, freqs, s, f, N);
    % for m = 1:N
    %     B_init(:, m) = B_init(:, m) / norm(B_init(:, m));
    %     W_init(:, m) = W_init(:, m) / norm(W_init(:, m));
    % end
    B = B_init;
    W = W_init;

    % Compute total dimension n
    s = r(1);  % Number of scalar blocks
    f = mm(1); % Number of full blocks
    
    if s==0
        n = sum(mm(2:end));
    elseif f==0
        n=sum(r(2:end));
    else
        n = sum(r(2:end)) + sum(mm(2:end)); % Total size of the uncertainty
    end

    num_freqs = N;
    [n_outputs, n_inputs] = size(G0);
    
    if n ~= n_outputs
        error('Mismatch: The total uncertainty dimension (%d) does not match the plant size (%d x %d)', n, n_outputs, n_inputs);
    end
    Z = zeros(size(B));

    mu_tilde = zeros(num_freqs, num_iters);
    mu_bar = zeros(num_freqs, num_iters);
    convergence_flags = false(1, num_freqs);
    

    for l = 1:num_iters
%% <<<<<<<<<  =====  First Experiment with G_0  =====    >>>>>>>>>>

        
        b_time=ifft(B,[],2,'symmetric');
        p_time = simulate_plant_general_discrete(G0, b_time,sigma);
        P_freq = fft(p_time,[],2);
%% <<<<<<<<< =====  End of First Experiment with G_0  =====    >>>>>>>>>

        for m = 1:num_freqs

            M_tilde = norm(P_freq(:, m));
           
            A = (1 / M_tilde) * P_freq(:, m);

            % Initialize structured uncertainty Z
            Z_rj = zeros(sum(r(2:end)), 1);
            Z_mk = zeros(sum(mm(2:end)), 1);

            % Process each scalar uncertainty block
            idx_r = 1;
            for j = 1:s
                r_j = r(j+1);
                W_rj = W(idx_r:idx_r+r_j-1, m);
                A_rj = A(idx_r:idx_r+r_j-1);
                Z_rj(idx_r:idx_r+r_j-1) = ((W_rj' * A_rj) / abs(W_rj' * A_rj)) * W_rj;
                idx_r = idx_r + r_j;
            end

            % Process each full uncertainty block
            idx_mm = sum(r(2:end)) + 1;
            for k = 1:f
                mm_k = mm(k+1);
                W_mk = W(idx_mm:idx_mm+mm_k-1, m);
                A_mk = A(idx_mm:idx_mm+mm_k-1);
                Z_mk(idx_mm-sum(r(2:end)):idx_mm-sum(r(2:end))+mm_k-1) = (norm(W_mk) / norm(A_mk)) * A_mk;
                idx_mm = idx_mm + mm_k;
            end

            
            if s>0 && f>0
                Z(:, m) = [Z_rj; Z_mk];
            elseif s==0
                Z(:, m) = Z_mk;
            elseif f==0
                Z(:, m) = Z_rj;
            end
          

            mu_tilde(m, l) = M_tilde;

        end

%% <<<<<<<<<<<  ===== Second Experiment with G_0^T  =====   >>>>>>>>> 

        Z_time=ifft(Z,[],2,'symmetric');
        Z_time=flip(Z_time,2);

        
        r_time = zeros(n_outputs, N);

        for alpha = 1:n_inputs
            for beta = 1:n_outputs
                %if ~isempty(G0{beta, alpha}) && ~all(G0{beta, alpha}.b == 0)
                e_alpha = zeros(n_inputs, 1);
                e_beta = zeros(n_outputs, 1);
                e_alpha(alpha) = 1;
                e_beta(beta) = 1;

                %u_time=  e_beta * (e_alpha' * Z_time);
                u_time = e_alpha * (e_beta' * Z_time);
                response = simulate_plant_general_discrete(G0, u_time,sigma);

                %response = e_beta * (e_alpha' * response);
                response = e_alpha * (e_beta' * response);
                r_time = r_time + response;
                %end
            end
        end

        r_time=flip(r_time,2);
        R_freq=fft(r_time,[],2);
%% <<<<<<<<<  ===== End of Second Experiment with G_0^T  =====   >>>>>>>>> 
        
        for m = 1:num_freqs     
            
            M_bar = norm(R_freq(:, m));
            W(:, m) = (1 / M_bar) * R_freq(:, m);

            % 
            % Initialize B blocks
            B_rj = zeros(sum(r(2:end)), 1);
            B_mk = zeros(sum(mm(2:end)), 1);

            % Process each scalar block
            idx_r = 1;
            for j = 1:s
                r_j = r(j+1);
                A_rj = A(idx_r:idx_r+r_j-1);
                W_rj = W(idx_r:idx_r+r_j-1, m);
                B_rj(idx_r:idx_r+r_j-1) = ((A_rj' * W_rj) / abs(A_rj' * W_rj)) * A_rj;
                idx_r = idx_r + r_j;
            end

            % Process each full block
            idx_mm = sum(r(2:end)) + 1;
            for k = 1:f
                mm_k = mm(k+1);
                A_mk = A(idx_mm:idx_mm+mm_k-1);
                W_mk = W(idx_mm:idx_mm+mm_k-1, m);
                B_mk(idx_mm-sum(r(2:end)):idx_mm-sum(r(2:end))+mm_k-1) = (norm(A_mk) / norm(W_mk)) * W_mk;
                idx_mm = idx_mm + mm_k;
            end
        
            % 
            if s > 0 && f > 0
                B(:, m) = [B_rj; B_mk];
            elseif s == 0
                B(:, m) = B_mk;
            elseif f == 0
                B(:, m) = B_rj;
            end
        
            mu_bar(m, l) = M_bar;
        end

        for m = 1:N
            B(:, m) = B(:, m) / norm(B(:, m));
            W(:, m) = W(:, m) / norm(W(:, m));
        end
        % norm_factor = sqrt(sum(vecnorm(B).^2)); % Sum of squared norms for all frequencies
        % B = B / norm_factor; % Normalize B
        for m = 1:num_freqs
            if l > 1
                %convergence_flags(m) = abs(mu_tilde(m, l) - mu_bar(m, l)) < tol2 && abs(mu_tilde(m, l) - mu_tilde(m, l - 1)) < tol && abs(mu_bar(m, l) - mu_bar(m, l - 1)) < tol;
                convergence_flags(m) = abs(mu_tilde(m, l) - mu_tilde(m, l - 1)) < tol && abs(mu_bar(m, l) - mu_bar(m, l - 1)) < tol;
            end
        end
        
        if all(convergence_flags)
            mu_tilde = mu_tilde(:, 1:l);
            mu_bar = mu_bar(:, 1:l);
            break;
        end
    end

    B_final = B;
    W_final = W;
end


%close all;

% ===== ss: Complex Scalars , f: Full Blocks =====
% n=3 %seed=11
%case 1
% ss = 1;
% f = 0;
% r = [ss,3];  % 1 3x3
% m = [f, 0];     
% %case 2
% ss = 0;
% f = 1;
% r = [ss,0];  %
% m = [f, 3];     % 1 3x3
% %case 3
% ss = 1;
% f = 1;
% r = [ss,2];  % 1 2x2
% m = [f, 1];     % 1 1x1
% %case 4
% ss = 1;
% f = 1;
% r = [ss,1];  % 1 1x1
% m = [f, 2];     % 1 2x2
% %case 5
% ss = 2;
% f = 1;
% r = [ss,1,1];  % 1 1x1
% m = [f, 1];     % 1 2x2
% %case 6
% ss = 1;
% f = 2;
% r = [ss,1];  % 1 1x1
% m = [f, 1,1];     % 1 2x2
% %case 7
% ss = 3;
% f = 0;
% r = [ss,1,1,1];  % 1 1x1
% m = [f,0];     % 1 2x2
% %case 8
% ss = 0;
% f = 3;
% r = [ss,0];  % 1 1x1
% m = [f,1,1,1];     % 1 2x2
% 
% %BlockStructure = [ss, 0; f, f];  
% BlockStructure = [1,0;1,0;1,0];  

% n = sum(r(2:end)) + sum(m(2:end));

% N = 1000;
% num_iters = 100;
% freqs = 2 * pi* (0:N-1) / N;

% ===== Discrete Plants =====

%% 1) DOYLE EXAMPLES
% Define the Laplace variable
% s = tf('s');
% 
% % Define the continuous-time plant G(s)
% %G_cont = (1/s) * [10 9; 9 8];
% G_cont=[ 9/(s + 1),  -10/(s + 1);
%      -8/(s + 2),   9/(s + 2)];
% 
% % Define controllers K1, K2, K3
% K1 = [-8 9; 9 -10];
% Q1 = [3/4 -2/3; 2/3 3/4];
% Q2 = [3/4 2/3; 2/3 -3/4];
% K2 = Q1 * Q2;
% K3 = Q1 * [
%     (10 * (s + 1)) / (3 * s * (s + 16)), 0;
%     0, (9 * (16 * s + 1)) / (32 * s * (s + 1))
% ] * Q2;
% K4= (1 / (0.0159 * s)) * [9*(s + 1),  10*(s + 2);
%                            8*(s + 1),   9*(s + 2)];
% % Function to compute M
% calculate_M = @(G, K) [
%     (eye(size(K)) + K * G) \ (K * G), (eye(size(K)) + K * G) \ K;
%     (eye(size(G)) + G * K) \ G, (eye(size(G)) + G * K) \ eye(size(G))
% ];
% % calculate_M = @(G, K) [
% %     (eye(size(K)) + K * G) \ (K * G), (eye(size(K)) + K * G) \ K;
% %     (eye(size(G)) + G * K) \ G, (eye(size(G)) + G * K) \ (G * K)
% % ];
% 
% 
% T_s=0.1;
% 
% %% Discretization
% % Discretize G(s) using the Tustin method
% Gd = c2d(G_cont, T_s, 'zoh');
% 
% % Discretize K3 (K1 and K2 are constants)
% K3d = c2d(K3, T_s, 'zoh');
% K4d = c2d(K3, T_s, 'zoh');
% 
% % Compute M1, M2, and M3 in discrete domain
% M1 = calculate_M(Gd, K1);
% M2 = calculate_M(Gd, K2);
% M3 = calculate_M(Gd, K3d);
% M4 = calculate_M(Gd, K4d);
% 
% % Pick plant (Choose one)
% G = M1;
% 
% 
% %% Convert to cell format for simulation
% [n_outputs, n_inputs] = size(G);
% G0 = cell(n_outputs, n_inputs);
% 
% for i = 1:n_outputs
%     for j = 1:n_inputs
%         % Get transfer function coefficients
%         [b, a] = tfdata(G(i, j), 'v');
% 
%         % Store in cell
%         G0{i, j} = struct('b', b, 'a', a);
%     end
% end



% display(M1);
% display(M2);
% display(M3);

%% RANDOM PLANTS
% n=2;
% n=3;
% n_outputs = n; % Number of outputs
% n_inputs = n;  % Number of inputs
% n_states = 2;  % Number of states (adjust as needed)
% seed=5;
% 
% % Generate random G0
% G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed);
% %G0= generate_scaled_G0(n_outputs, n_inputs, n_states, freqs);

%% GENERAL PLANTS

% % Definir matrices del sistema en tiempo continuo
% clear ss
% A = [-2  -400   0.1   0.2;
%       1     0   0.5   0;
%       0     2  -3    -80;
%       0     0   1     0];
% 
% B = [2  0.8;
%      0   0;
%      0   1;
%      1   0];
% 
% C = [1.5  0   1   0;
%      0    1   2   2];
% 
% D = zeros(size(C,1), size(B,2)); % Matriz D (suponemos que es cero)
% 
% % Definir tiempo de muestreo
% Ts = 0.01; % Especificado en la pregunta
% 
% % Crear sistema en espacio de estados continuo
% sys_c = ss(A, B, C, D);
% 
% % Discretizar usando Zero-Order Hold (ZOH)
% sys_d = c2d(sys_c, Ts, 'zoh');
% 
% % Obtener la función de transferencia discreta
% [num, den] = tfdata(sys_d, 'v'); % Extraer coeficientes de num y den
% 
% % Crear la estructura de celdas G0
% [n_outputs, n_inputs] = size(sys_d);
% 
% G0 = cell(n_outputs, n_inputs);
% 
% for i = 1:n_outputs
%     for j = 1:n_inputs
%         G0{i, j} = struct('b', num{i, j}, 'a', den{i, j});
%     end
% end


% G0 = {struct('b', [1], 'a', [1, -0.1])}; 

% G0 = {
%     struct('b', [1], 'a', [1, -0.5]), struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]), struct('b', [0.7], 'a', [1, -0.3])
% };

% G0 = {
%     struct('b', [1], 'a', [1, -0.5]), struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]), struct('b', [2], 'a', [1, -0.7])
% };
% 
% G0 = {
%    struct('b', [1], 'a', [1, -0.5]), struct('b', [1], 'a', [1, -0.5]);
%    struct('b', [1], 'a', [1, -0.5]), struct('b', [2], 'a', [1, -0.7])
% };
% 
% G0 = {
%     struct('b', [1], 'a', [1, -0.5]), struct('b', [0.5], 'a', [1, -0.3]);
%     struct('b', [0.3], 'a', [1, -0.7]), struct('b', [2], 'a', [1, -0.9])
% };
% G0 = {
%     struct('b',[1],   'a',[1, -0.5]),  struct('b',[0.2], 'a',[1, -0.3]), struct('b',[0.3], 'a',[1, -0.6]);
%     struct('b',[0.2], 'a',[1, -0.3]),  struct('b',[1.5], 'a',[1, -0.8]), struct('b',[0.4], 'a',[1, -0.7]);
%     struct('b',[0.3], 'a',[1, -0.6]),  struct('b',[0.4], 'a',[1, -0.7]), struct('b',[2],   'a',[1, -0.9])
% };

% G0 = {
%     struct('b',[1],   'a',[1, -0.4]),  struct('b', [0], 'a', [1]) ,   struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]) ,   struct('b',[1.5], 'a',[1, -0.1]), struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]) ,   struct('b', [0], 'a', [1]) ,  struct('b',[2],   'a',[1, -0.3])
% };
% G0 = {
%     struct('b', [1, -0.5], 'a', [1, -0.3]), struct('b', [0.2, -0.1], 'a', [1, -0.4]), struct('b', [0.3, -0.2], 'a', [1, -0.5]), struct('b', [0.4, -0.3], 'a', [1, -0.6]);
%     struct('b', [0.2, -0.1], 'a', [1, -0.4]), struct('b', [1.5, -0.6], 'a', [1, -0.7]), struct('b', [0.5, -0.3], 'a', [1, -0.5]), struct('b', [0.6, -0.4], 'a', [1, -0.7]);
%     struct('b', [0.3, -0.2], 'a', [1, -0.5]), struct('b', [0.5, -0.3], 'a', [1, -0.5]), struct('b', [2.0, -0.7], 'a', [1, -0.8]), struct('b', [0.7, -0.5], 'a', [1, -0.6]);
%     struct('b', [0.4, -0.3], 'a', [1, -0.6]), struct('b', [0.6, -0.4], 'a', [1, -0.7]), struct('b', [0.7, -0.5], 'a', [1, -0.6]), struct('b', [2.5, -0.9], 'a', [1, -0.9])
% };
% G0 = {
%     struct('b', [1, -0.5], 'a', [1, -0.3]), struct('b', [0], 'a', [1]), struct('b', [0], 'a', [1]), struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]), struct('b', [1.5, -0.6], 'a', [1, -0.7]), struct('b', [0], 'a', [1]), struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]), struct('b', [0], 'a', [1]), struct('b', [2.0, -0.7], 'a', [1, -0.8]), struct('b', [0], 'a', [1]);
%     struct('b', [0], 'a', [1]), struct('b', [0], 'a', [1]), struct('b', [0], 'a', [1]), struct('b', [2.5, -0.9], 'a', [1, -0.9])
% };
%% Example for blocks

% ===== Initial Parameters ===== 
% Dimension (fixed at 3)
% n = 3; 
% 
% n_outputs = n; % Number of outputs
% n_inputs = n;  % Number of inputs
% n_states = 2;  % Number of states (adjust as needed)
% seed=5;
% 
% % Generate random G0
% G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed);
% 
% [n_outputs, n_inputs] = size(G0);
% 
% % Define the different cases
% cases = {
%     [1, 3], [0, 0];  % Case 1: Scalar 3x3
%     [0, 0], [1, 3];  % Case 2: Full block 3x3
%     [1, 2], [1, 1];  % Case 3: Scalar 2x2, Full 1x1
%     [1, 1], [1, 2];  % Case 4: Scalar 1x1, Full 2x2 --> case for noise
%     [2, 1, 1], [1, 1];  % Case 5: Scalar 1x1, 1x1, Full 2x2
%     [1, 1], [2, 1, 1];  % Case 6: Scalar 1x1, Full 1x1, 1x1
%     [3, 1, 1, 1], [0, 0];  % Case 7: 3 separate scalars
%     [0, 0], [3, 1, 1, 1]   % Case 8: 3 separate full blocks
% };
% cases_mussv = {
%     [3, 0]; 
%     [3, 3]; 
%     [2, 0; 1, 1]; 
%     [1, 0; 2, 2]; 
%     [1, 0; 1, 0; 1, 1]; 
%     [1, 0; 1, 1; 1, 1]; 
%     [1, 0; 1, 0; 1, 0]; 
%     [1, 1; 1, 1; 1, 1]
% };
% 
% 
% % Select a reduced set of N values (ensuring all are even)
% N_values = [10, 100, 300, 500, 700, 1000, 1500, 3000, 5000, 7000, 10000];
% 
% % Initialize figure
% figure;
% set(gca,'Box','on')
% hold on;
% grid on;
% xlabel('Total Number of Frequencies $(N)$');
% ylabel('$\mu_{\Delta}(G_0)$');
% %title('Comparison of Different Uncertainty Structures');
% 
% % Generate better colors for differentiation
% colors = parula(length(cases));  
% markers_tilde = {'o', 's', 'd', '^', 'v', 'p', 'h', 'x'}; 
% markers_bar = {'+', '*', '<', '>', '.', '|', '_', 'x'};  
% 
% % Iterate over different cases
% for case_idx = 1:length(cases)
%     r = cases{case_idx, 1}; 
%     m = cases{case_idx, 2}; 
%     mussv_block = cases_mussv{case_idx};  
% 
%     mu_tilde_values = zeros(1, length(N_values));
%     mu_bar_values = zeros(1, length(N_values));
%     mussv_values = zeros(1, length(N_values));
% 
%     for n_idx = 1:length(N_values)
%         N = N_values(n_idx);
% 
%         % Generate B and W inside the loop to maintain symmetry
%         B_freq = randn(n, N) + 1j * randn(n, N);
%         W_freq = randn(n, N) + 1j * randn(n, N);
% 
%         % ===== Apply Symmetry on B and W for Tom Oomen Algorithm =====
%         for i = 1:n
%             B_freq(i, [1, N/2+1]) = real(B_freq(i, [1, N/2+1]));
%             W_freq(i, [1, N/2+1]) = real(W_freq(i, [1, N/2+1]));
%             B_freq(i, 2:N/2) = B_freq(i, 2:N/2);
%             B_freq(i, N:-1:N/2+2) = conj(B_freq(i, 2:N/2));
%             W_freq(i, 2:N/2) = W_freq(i, 2:N/2);
%             W_freq(i, N:-1:N/2+2) = conj(W_freq(i, 2:N/2));
%         end
% 
%         % Run the power method
%         [mu_tilde, mu_bar, ~, ~] = power_method_convergence(G0, B_freq, W_freq, 100, r, m, 1e-6, 1e-1, N);
% 
%         % Store final values
%         mu_tilde_values(n_idx) = max(mu_tilde(:, end));
%         mu_bar_values(n_idx) = max(mu_bar(:, end));
% 
%         % Compute MUSSV Lower Bound
%         freqs = 2 * pi * (0:N-1) / N;
%         G_frd = zeros(n, n, N);  
%         for m_idx = 1:N
%             Gf = evaluate_discrete_tf(G0, freqs(m_idx));
%             G_frd(:, :, m_idx) = Gf;
%         end
%         G_mussv = frd(G_frd, freqs);
%         [bounds, ~] = mussv(G_mussv, mussv_block);
%         mussv_values(n_idx) = max(bounds(1).ResponseData(:));  
%     end
% 
%     % Plot results: Interpolation for smooth curves
%     plot(N_values, mu_tilde_values, ['-', markers_tilde{mod(case_idx - 1, length(markers_tilde)) + 1}], ...
%         'Color', colors(case_idx, :), 'DisplayName', ['Case ', num2str(case_idx), ' $\tilde{\mu}$'], ...
%         'LineWidth', 1.2, 'MarkerSize', 6);
% 
%     plot(N_values, mu_bar_values, ['--', markers_bar{mod(case_idx - 1, length(markers_bar)) + 1}], ...
%         'Color', colors(case_idx, :), 'DisplayName', ['Case ', num2str(case_idx), ' $\bar{\mu}$'], ...
%         'LineWidth', 1.2, 'MarkerSize', 6);
% 
%     % Plot MUSSV with a dotted line
%     plot(N_values, mussv_values, ':', 'Color', colors(case_idx, :), ...
%         'DisplayName', ['Case ', num2str(case_idx), ' MUSSV'], 'LineWidth', 1.2);
% 
%     % Añadir el interpreter LaTeX a la leyenda
%     legend('show', 'Location', 'best', 'Interpreter', 'latex');
% end

% Add reference line for mussv lower bound
%yline(3.3819, 'k--', 'LineWidth', 1.8, 'DisplayName', 'MUSSV Lower Bound');

% % Configure legend and log-scale
% legend('show', 'Location', 'best');
% set(gca, 'XScale', 'log'); % Log scale for better visualization
% hold off;
% print('-depsc2', 'cases.eps');

%% Graficos BLOCKS

% n = 3; 
% 
% n_outputs = n; % Number of outputs
% n_inputs = n;  % Number of inputs
% n_states = 2;  % Number of states (adjust as needed)
% seed=5;
% 
% % Generate random G0
% G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed);
% [n_outputs, n_inputs] = size(G0);
% 
% % Define the different cases
% cases = {
%     [1, 3], [0, 0];  % Case 1: Scalar 3x3
%     [0, 0], [1, 3];  % Case 2: Full block 3x3
%     [1, 2], [1, 1];  % Case 3: Scalar 2x2, Full 1x1
%     [1, 1], [1, 2];  % Case 4: Scalar 1x1, Full 2x2
%     [2, 1, 1], [1, 1];  % Case 5: Scalar 1x1, 1x1, Full 2x2
%     [1, 1], [2, 1, 1];  % Case 6: Scalar 1x1, Full 1x1, 1x1
%     [3, 1, 1, 1], [0, 0];  % Case 7: 3 separate scalars
%     [0, 0], [3, 1, 1, 1]   % Case 8: 3 separate full blocks
% };
% cases_mussv = {
%     [3, 0]; 
%     [3, 3]; 
%     [2, 0; 1, 1]; 
%     [1, 0; 2, 2]; 
%     [1, 0; 1, 0; 1, 1]; 
%     [1, 0; 1, 1; 1, 1]; 
%     [1, 0; 1, 0; 1, 0]; 
%     [1, 1; 1, 1; 1, 1]
% };
% % 
% % n = 3; 
% % 
% % n_outputs = n; % Number of outputs
% % n_inputs = n;  % Number of inputs
% % n_states = 2;  % Number of states (adjust as needed)
% % seed=5;
% % 
% % % Generate random G0
% % G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed);
% % [n_outputs, n_inputs] = size(G0);
% % 
% % % Define the different cases
% % cases = {
% %     [1, 3], [0, 0];  % Case 1: Scalar 3x3
% %     [0, 0], [1, 3];  % Case 2: Full block 3x3
% %     [1, 2], [1, 1];  % Case 3: Scalar 2x2, Full 1x1
% %     [1, 1], [1, 2];  % Case 4: Scalar 1x1, Full 2x2
% %     [2, 1, 1], [1, 1];  % Case 5: Scalar 1x1, 1x1, Full 2x2
% %     [1, 1], [2, 1, 1];  % Case 6: Scalar 1x1, Full 1x1, 1x1
% %     [3, 1, 1, 1], [0, 0];  % Case 7: 3 separate scalars
% %     [0, 0], [3, 1, 1, 1]   % Case 8: 3 separate full blocks
% % };
% % cases_mussv = {
% %     [3, 0]; 
% %     [3, 3]; 
% %     [2, 0; 1, 1]; 
% %     [1, 0; 2, 2]; 
% %     [1, 0; 1, 0; 1, 1]; 
% %     [1, 0; 1, 1; 1, 1]; 
% %     [1, 0; 1, 0; 1, 0]; 
% %     [1, 1; 1, 1; 1, 1]
% % };
% 
% % Define values for N
% N_values = [10, 100, 300, 500, 700, 1000, 1500, 3000, 5000, 7000, 10000];
% 
% % Definir colores y marcadores según lo indicado
% colors = {'r', 'b', 'r', 'b', 'r', 'b', 'g', 'm'}; % Colores correctos para cada caso
% markers = {'o', 's', 'd', '^', 'v', 'p', 'h', '*'}; % 8 marcadores distintos
% 
% % Matrices para almacenar valores de mu
% num_cases = length(cases);
% mu_tilde_values = zeros(num_cases, length(N_values));
% mu_bar_values = zeros(num_cases, length(N_values));
% mussv_values = zeros(num_cases, length(N_values));
% 
% % ======= Simulación para cada caso =======
% for case_idx = 1:num_cases
%     r = cases{case_idx, 1}; 
%     m = cases{case_idx, 2}; 
%     mussv_block = cases_mussv{case_idx};  
% 
%     for n_idx = 1:length(N_values)
%         N = N_values(n_idx);
% 
%         % Generación de B y W
%         B_freq = randn(n, N) + 1j * randn(n, N);
%         W_freq = randn(n, N) + 1j * randn(n, N);
% 
%         for i = 1:n
%             B_freq(i, [1, N/2+1]) = real(B_freq(i, [1, N/2+1]));
%             W_freq(i, [1, N/2+1]) = real(W_freq(i, [1, N/2+1]));
%             B_freq(i, 2:N/2) = B_freq(i, 2:N/2);
%             B_freq(i, N:-1:N/2+2) = conj(B_freq(i, 2:N/2));
%             W_freq(i, 2:N/2) = W_freq(i, 2:N/2);
%             W_freq(i, N:-1:N/2+2) = conj(W_freq(i, 2:N/2));
%         end
% 
%         % Método de potencia
%         [mu_tilde, mu_bar, ~, ~] = power_method_convergence(G0, B_freq, W_freq, 100, r, m, 1e-6, 1e-1, N,0);
% 
%         % Guardar valores finales
%         mu_tilde_values(case_idx, n_idx) = max(mu_tilde(:, end));
%         mu_bar_values(case_idx, n_idx) = max(mu_bar(:, end));
% 
%         % Cálculo de MUSSV
%         freqs = 2 * pi * (0:N-1) / N;
%         G_frd = zeros(n, n, N);  
%         for m_idx = 1:N
%             Gf = evaluate_discrete_tf(G0, freqs(m_idx));
%             G_frd(:, :, m_idx) = Gf;
%         end
%         G_mussv = frd(G_frd, freqs);
%         [bounds, ~] = mussv(G_mussv, mussv_block);
%         mussv_values(case_idx, n_idx) = max(bounds(1).ResponseData(:));  
%     end
% end
% 
% % ======= Graficar =======
% %% Figura 1: Gráficos sin leyenda
% figure;
% 
% % Configurar layout para reducir espacios
% tiledlayout(3,1, 'Padding', 'tight', 'TileSpacing', 'compact');
% 
% % Subgráficos
% for subplot_idx = 1:3
%     nexttile;
%     hold on;
%     set(gca, 'Box', 'on');
% 
%     % Casos a graficar
%     if subplot_idx == 1
%         cases_to_plot = [1, 2];
%     elseif subplot_idx == 2
%         cases_to_plot = [3, 4];
%     else
%         cases_to_plot = [5, 6, 7, 8];
%     end
% 
%     % Graficar cada caso
%     for i = 1:length(cases_to_plot)
%         case_id = cases_to_plot(i);
%         color = colors{case_id};
%         marker = markers{case_id};
% 
%         % mu_tilde
%         plot(N_values, mu_tilde_values(case_id, :), ['-', marker], ...
%             'Color', color, 'LineWidth', 0.7, 'MarkerFaceColor', color, ...
%             'MarkerSize', 4, 'HandleVisibility', 'off'); % Sin leyenda
% 
%         % mu_bar
%         plot(N_values, mu_bar_values(case_id, :), ['--', marker], ...
%             'Color', color, 'LineWidth', 0.7, 'MarkerFaceColor', color, ...
%             'MarkerSize', 4, 'HandleVisibility', 'off'); % Sin leyenda
% 
%         % mussv
%         plot(N_values, mussv_values(case_id, :), ':', ...
%             'Color', color, 'LineWidth', 1, 'HandleVisibility', 'off'); % Sin leyenda
%     end
% 
%     % Etiquetas de eje Y en todos los gráficos
%     ylabel('$\mu_{\Delta}(G_0)$', 'Interpreter', 'latex', 'FontSize', 10);
% 
%     % Solo el último gráfico tiene el eje X visible (0 a 10000)
%     if subplot_idx == 3
%         xlabel('Total Frequencies $(N)$', 'Interpreter', 'latex', 'FontSize', 10);
%         set(gca, 'XTick', 0:2000:10000); % Eje X de 0 a 10000 solo en el último
%     else
%         set(gca, 'XTickLabel', []); % Ocultar etiquetas del eje X en los demás
%     end
% end
% 
% % Guardar la figura sin leyenda
% print('-depsc2', 'cases.eps');
% 
% 
% %% Figura 2: Leyenda aparte
% figure;
% 
% % Dibujar leyenda en una figura separada
% hold on;
% legend_entries = cell(1, 8);
% 
% for i = 1:8
%     % Dibujar una línea invisible con el color y marcador correcto
%     plot(NaN, NaN, ['-', markers{i}], 'Color', colors{i}, 'LineWidth', 1.2, ...
%         'MarkerFaceColor', colors{i}, 'MarkerSize', 6);
% 
%     % Asignar la etiqueta correctamente
%     legend_entries{i} = sprintf('Case %d', i);
% end
% 
% % Crear la leyenda correctamente alineada en 2 filas
% lgd = legend(legend_entries, 'Location', 'southoutside', 'Orientation', 'horizontal');
% set(lgd, 'Interpreter', 'latex', 'FontSize', 10, 'NumColumns', 4); % 2 filas de 4 elementos
% 
% % Guardar solo la leyenda
% axis off; % No mostrar ejes
% print('-depsc2', 'legend_fix.eps');

% figure;
% 
% % Subgráficos
% for subplot_idx = 1:3
%     subplot(3,1,subplot_idx);
%     hold on;
%     set(gca, 'Box', 'on');
% 
%     % Casos a graficar
%     if subplot_idx == 1
%         cases_to_plot = [1, 2];
%     elseif subplot_idx == 2
%         cases_to_plot = [3, 4];
%     else
%         cases_to_plot = [5, 6, 7, 8];
%     end
% 
%     % Graficar cada caso
%     for i = 1:length(cases_to_plot)
%         case_id = cases_to_plot(i);
%         color = colors{case_id};
%         marker = markers{case_id};
% 
%         % mu_tilde
%         plot(N_values, mu_tilde_values(case_id, :), ['-', marker], ...
%             'Color', color, 'LineWidth', 0.7, 'MarkerFaceColor', color, ...
%             'MarkerSize', 4, 'HandleVisibility', 'off'); % Sin leyenda
% 
%         % mu_bar
%         plot(N_values, mu_bar_values(case_id, :), ['--', marker], ...
%             'Color', color, 'LineWidth', 0.7, 'MarkerFaceColor', color, ...
%             'MarkerSize', 4, 'HandleVisibility', 'off'); % Sin leyenda
% 
%         % mussv
%         plot(N_values, mussv_values(case_id, :), ':', ...
%             'Color', color, 'LineWidth', 1, 'HandleVisibility', 'off'); % Sin leyenda
%     end
% 
%     % Eje Y solo en el gráfico del medio
%     % if subplot_idx == 2
%     %     ylabel('$\mu_{\Delta}(G_0)$', 'Interpreter', 'latex', 'FontSize', 10);
%     % else
%     %     set(gca, 'YTickLabel', []); % Ocultar etiquetas de eje Y en los otros gráficos
%     % end
%     ylabel('$\mu_{\Delta}(G_0)$', 'Interpreter', 'latex', 'FontSize', 10);
% end
% 
% % Etiqueta del eje X solo en el gráfico inferior
% xlabel('Total Frequencies $(N)$', 'Interpreter', 'latex', 'FontSize', 10);
% 
% colors = {'r', 'b', 'r', 'b', 'r', 'b', 'g', 'm'}; % Rojo, azul, verde, naranja
% markers = {'o', 's', 'd', '^', 'v', 'p', 'h', '*'}; % 8 marcadores distintos
% 
% 
% % Lista de etiquetas para la leyenda
% legend_entries = cell(1, 8);
% 
% for i = 1:8
%     % Dibujar una línea invisible con el color y marcador correcto
%     plot(NaN, NaN, ['-', markers{i}], 'Color', colors{i}, 'LineWidth', 1.2, ...
%         'MarkerFaceColor', colors{i}, 'MarkerSize', 6);
% 
%     % Asignar la etiqueta correctamente
%     legend_entries{i} = sprintf('Case %d', i);
% end
% 
% % Crear la leyenda correctamente alineada
% % lgd = legend(legend_entries, 'Location', 'southoutside', 'Orientation', 'horizontal');
% % set(lgd, 'Interpreter', 'latex', 'FontSize', 10);
% % Crear la leyenda correctamente alineada con dos filas (4 elementos por fila)
% lgd = legend(legend_entries, 'Location', 'southoutside', 'Orientation', 'horizontal');
% set(lgd, 'Interpreter', 'latex', 'FontSize', 10, 'NumColumns', 4); % ← Divide en 2 líneas
% 
% 
% hold off;
% print('-depsc2', 'legend_fix.eps');





% %% Verify lower and upper bound of cases
% 
% n=3;
% n_outputs = n; % Number of outputs
% n_inputs = n;  % Number of inputs
% n_states = 2;  % Number of states (adjust as needed)
% seed=5;
% 
% % Generate random G0
% G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed);
% 
% [n_outputs, n_inputs] = size(G0);
% 
% % Number of states (fixed at 3)
% n = 3; 
% 
% % Define the case
% mussv_block = [1, 0; 2, 2];  % MUSSV block structure
% 
% %     [1, 3], [0, 0];  % Case 1: Scalar 3x3
% %     [0, 0], [1, 3];  % Case 2: Full block 3x3
% %     [1, 2], [1, 1];  % Case 3: Scalar 2x2, Full 1x1
% %     [1, 1], [1, 2];  % Case 4: Scalar 1x1, Full 2x2 --> case for noise
% %     [2, 1, 1], [1, 1];  % Case 5: Scalar 1x1, 1x1, Full 2x2
% %     [1, 1], [2, 1, 1];  % Case 6: Scalar 1x1, Full 1x1, 1x1
% %     [3, 1, 1, 1], [0, 0];  % Case 7: 3 separate scalars
% %     [0, 0], [3, 1, 1, 1]   % Case 8: 3 separate full blocks
% 
% % cases_mussv = {
% %     [3, 0]; s=1 - min mussv: 2.6078, min muussv: 2.6078
% %     [3, 3]; s=1 - min mussv: 3.5582, min muussv: 3.5582
% %     [2, 0; 1, 1];  s=1 f=1 - min mussv: 3.3701, min muussv: 3.3699
% %     [1, 0; 2, 2];  s=1 f=1 - min mussv: 3.4833, min muussv: 3.4833
% %     [1, 0; 1, 0; 1, 1]; s=2 f=1 - in mussv: 3.3819, min muussv: 3.3815
% %     [1, 0; 1, 1; 1, 1]; s=1 f=2 - min mussv: 3.3819, min muussv: 3.3815
% %     [1, 0; 1, 0; 1, 0]; s=3 - min mussv: 3.3819, min muussv: 3.3815
% %     [1, 1; 1, 1; 1, 1] ; f=3 - min mussv: 3.3819, min muussv: 3.3815
% % };
% 
% % Define the number of frequencies (N)
% N = 10000;
% freqs = 2 * pi * (0:N-1) / N; % Positive frequencies only
% 
% % % ===== Compute MUSSV Lower Bound =====
% G_frd = zeros(n, n, N);  % Storage for frequency responses
% for m_idx = 1:N
%     Gf = evaluate_discrete_tf(G0, freqs(m_idx)); % Evaluate plant at each frequency
%     G_frd(:, :, m_idx) = Gf;
% end
% 
% % Create frequency response model
% G_mussv = frd(G_frd, freqs);
% 
% [bounds, ~] = mussv(G_mussv, mussv_block);
% 
% % Extract lower and upper bounds
% mu_lower = bounds(1); % Lower bound (frd object)
% mu_upper = bounds(2); % Upper bound (frd object)
% 
% % ===== Maximun and frequencies =====
% % Compute max values
% [max_value_mussv_lower, max_index_mussv_lower] = max(mu_lower.ResponseData(:));
% [max_value_mussv_upper, max_index_mussv_upper] = max(mu_upper.ResponseData(:));
% 
% % freqm = ((2*pi/N) * ([max_index_tilde max_index_bar max_index_mussv_lower max_index_mussv_upper max_index_real] - 1));
% 
% freqm = [freqs(max_index_mussv_lower), freqs(max_index_mussv_upper)];
% 
% fprintf('<strong>===== MUSSV =====</strong>\n');
% fprintf('min mussv: %.4f, max muussv: %.4f\n',max_value_mussv_lower, max_value_mussv_upper);
% fprintf('<strong>===== MUSSV freq =====</strong>\n');
% fprintf('freq min mussv: %.4f, freq max muussv: %.4f\n',freqm(1), freqm(2));
% 
% 
% %% iterations 1 block, 2 blocks and 3 blocks
% n = 3;  % Número de estados
% n_outputs = n; 
% n_inputs = n;  
% n_states = 2;  
% seed = 5;
% 
% % Generar sistema aleatorio
% G0 = generate_random_G0(n_outputs, n_inputs, n_states, seed);
% 
% % Definir los casos con colores y leyendas
% cases = {
%     struct('r', [0, 0], 'm', [1, 3], 'mussv_block', [3, 3], 'name', '1 Block', 'color', 'r'), % Caso 1
%     struct('r', [1, 1], 'm', [1, 2], 'mussv_block', [1, 0; 2, 2], 'name', '2 Blocks', 'color', 'b'), % Caso 2
%     struct('r', [2, 1, 1], 'm', [1, 1], 'mussv_block', [1, 0; 1, 0; 1, 1], 'name', '3 Blocks', 'color', 'g') % Caso 3
% };

% cases = {
%     struct('r', [2, 1, 1], 'm', [1, 1], 'mussv_block', [1, 0; 1, 0; 1, 1], 'name', '(s,f)=(2,1)', 'color', 'r'), % Caso 3
%     struct('r', [1, 1], 'm', [2, 1, 1], 'mussv_block', [1, 0; 1, 1; 1, 1], 'name', '(s,f)=(1,2)', 'color', 'b'), % Caso 2
%     struct('r', [3, 1, 1, 1], 'm', [0, 0], 'mussv_block', [1, 0; 1, 0; 1, 0], 'name', '(s,f)=(3,0)', 'color', 'g'), % Caso 3
%     struct('r', [0, 0], 'm', [3, 1, 1, 1], 'mussv_block', [1, 1; 1, 1; 1, 1], 'name', '(s,f)=(0,3)', 'color', 'm') % Caso 2
% };


% % cases = {
% %     [1, 3], [0, 0];  % Case 1: Scalar 3x3
% %     [0, 0], [1, 3];  % Case 2: Full block 3x3
% %     [1, 2], [1, 1];  % Case 3: Scalar 2x2, Full 1x1
% %     [1, 1], [1, 2];  % Case 4: Scalar 1x1, Full 2x2
% %     [2, 1, 1], [1, 1];  % Case 5: Scalar 1x1, 1x1, Full 2x2
% %     [1, 1], [2, 1, 1];  % Case 6: Scalar 1x1, Full 1x1, 1x1
% %     [3, 1, 1, 1], [0, 0];  % Case 7: 3 separate scalars
% %     [0, 0], [3, 1, 1, 1]   % Case 8: 3 separate full blocks
% % };
% % cases_mussv = {
% %     [3, 0]; 
% %     [3, 3]; 
% %     [2, 0; 1, 1]; 
% %     [1, 0; 2, 2]; 
% %     [1, 0; 1, 0; 1, 1]; 
% %     [1, 0; 1, 1; 1, 1]; 
% %     [1, 0; 1, 0; 1, 0]; 
% %     [1, 1; 1, 1; 1, 1]
% % };

% stabilization_threshold = 1e-4;  % Umbral para detectar convergencia
% 
% % Definir número de frecuencias
% N = 10000;
% B_freq = randn(n, N) + 1j * randn(n, N);
% W_freq = randn(n, N) + 1j * randn(n, N);
% 
% % Aplicar simetría en B y W
% for j = 1:n
%     B_freq(j, [1, N/2+1]) = real(B_freq(j, [1, N/2+1]));
%     W_freq(j, [1, N/2+1]) = real(W_freq(j, [1, N/2+1]));
%     B_freq(j, 2:N/2) = B_freq(j, 2:N/2);
%     B_freq(j, N:-1:N/2+2) = conj(B_freq(j, 2:N/2));
%     W_freq(j, 2:N/2) = W_freq(j, 2:N/2);
%     W_freq(j, N:-1:N/2+2) = conj(W_freq(j, 2:N/2));
% end
% 
% % Inicializar figura
% figure; hold on; set(gca, 'Box', 'on');
% xlabel('Number of Iterations $(l)$', 'Interpreter', 'latex', 'FontSize', 10);
% ylabel('$\mu$ Values', 'Interpreter', 'latex', 'FontSize', 10);
% %title('Convergence of $\tilde{\mu}$ and $\bar{\mu}$', 'Interpreter', 'latex', 'FontSize', 12);
% 
% % Arreglo para almacenar handles de las leyendas
% legend_handles = gobjects(1, length(cases));
% legend_entries = cell(1, length(cases));
% 
% for i = 1:length(cases)
%     case_data = cases{i};
%     r = case_data.r;
%     m = case_data.m;
%     mussv_block = case_data.mussv_block;
% 
%     num_iterations = 1;  % Comenzar con 1 iteración
%     converged = false;  % Estado de convergencia
% 
%     max_mu_tilde = [];
%     max_mu_bar = [];
% 
%     while ~converged
%         % Ejecutar el método de potencia con el número de iteraciones actual
%         [mu_tilde, mu_bar, ~, ~] = power_method_convergence(G0, B_freq, W_freq, num_iterations, r, m, 1e-6, 1e-1, N, 0);
% 
%         % Obtener el máximo en cada iteración
%         max_mu_tilde(num_iterations) = max(mu_tilde(:, end));
%         max_mu_bar(num_iterations) = max(mu_bar(:, end));
% 
%         % Verificar convergencia comparando con la iteración anterior
%         if num_iterations > 1
%             tilde_converged = abs(max_mu_tilde(num_iterations) - max_mu_tilde(num_iterations - 1)) < stabilization_threshold;
%             bar_converged = abs(max_mu_bar(num_iterations) - max_mu_bar(num_iterations - 1)) < stabilization_threshold;
% 
%             % Si ambos valores convergen, detener iteraciones
%             if tilde_converged && bar_converged
%                 converged = true;
%             end
%         end
% 
%         % Aumentar iteraciones
%         num_iterations = num_iterations + 1;
%     end
% 
%     % Ajustar longitud de vector de iteraciones
%     iter_vector = 1:(num_iterations - 1);
% 
%     % Graficar \tilde{\mu} con línea sólida
%     plot(iter_vector, max_mu_tilde, '-', 'Color', case_data.color, 'LineWidth', 0.7, ...
%         'HandleVisibility', 'off');
% 
%     % Graficar \bar{\mu} con línea punteada
%     plot(iter_vector, max_mu_bar, '--', 'Color', case_data.color, 'LineWidth', 0.7, ...
%         'HandleVisibility', 'off');
% 
%     % Añadir línea vertical donde se estabilizó
%     xline(iter_vector(end), ':', 'Color', case_data.color, 'LineWidth', 1);
% 
%     % Crear una línea invisible para la leyenda (solo color y nombre del caso)
%     legend_handles(i) = plot(NaN, NaN, '-', 'Color', case_data.color, 'LineWidth', 0.2);
%     legend_entries{i} = case_data.name;
% end
% 
% % Configurar la leyenda con solo los colores y nombres de los casos
% lgd = legend(legend_handles, legend_entries, 'Interpreter', 'latex', 'FontSize', 11, 'Location', 'northeast');
% xlim([1, 17]); % Define el rango del eje X de 1 a 17
% ylim([2, 10]); % Define el rango del eje Y de 0 a 14
% hold off;
% print('-depsc2', 'iteration.eps');


%% Noise Example Case 4 WITHOUT NOISE
% ===== Case 4: Scalar 1x1, Full 2x2 =====

n=3;
n_outputs = n; % Number of outputs
n_inputs = n;  % Number of inputs
n_states = 2;  % Number of states (adjust as needed)
seed=5;

% Generate random G0
G0 = generate_random_G0(n_outputs, n_inputs, n_states,seed);

clc;

% ===== Load System (Example Case 4: Scalar 1x1, Full 2x2) =====
[n_outputs, n_inputs] = size(G0);

% Number of states (fixed at 3)
n = 3; 

% Define the case
r = [1, 1];  % 1x1 scalar
m = [1, 2];  % 2x2 full block
mussv_block = [1, 0; 2, 2];  % MUSSV block structure

% Define the number of frequencies (N)
N = 10000;

% Generate frequency vector
freqs = 2 * pi * (0:N-1) / N; % Positive frequencies only

% ===== Generate Random B and W Matrices =====
B_freq = randn(n, N) + 1j * randn(n, N);
W_freq = randn(n, N) + 1j * randn(n, N);

% ===== Apply Symmetry on B and W for Tom Oomen Algorithm =====
for i = 1:n
    B_freq(i, [1, N/2+1]) = real(B_freq(i, [1, N/2+1]));
    W_freq(i, [1, N/2+1]) = real(W_freq(i, [1, N/2+1]));
    B_freq(i, 2:N/2) = B_freq(i, 2:N/2);
    B_freq(i, N:-1:N/2+2) = conj(B_freq(i, 2:N/2));
    W_freq(i, 2:N/2) = W_freq(i, 2:N/2);
    W_freq(i, N:-1:N/2+2) = conj(W_freq(i, 2:N/2));
end

% ===== Run the Power Method =====
[mu_tilde, mu_bar, ~, ~] = power_method_convergence(G0, B_freq, W_freq, 100, r, m, 1e-6, 1e-1, N,0);

% ===== Compute MUSSV Lower Bound =====
G_frd = zeros(n, n, N);  % Storage for frequency responses
for m_idx = 1:N
    Gf = evaluate_discrete_tf(G0, freqs(m_idx)); % Evaluate plant at each frequency
    G_frd(:, :, m_idx) = Gf;
end

% Create frequency response model
G_mussv = frd(G_frd, freqs);

% Compute MUSSV lower bound
[bounds, ~] = mussv(G_mussv, mussv_block);
mussv_lower_values = bounds(1).ResponseData(:); % Extract lower bound as vector
[max_mussv_value, max_mussv_idx] = max(mussv_lower_values);
max_mussv_freq =2*pi - freqs(max_mussv_idx);


% ===== Extract Last Iteration Values for Power Method =====
mu_tilde_final = mu_tilde(:, end);  % Last iteration of mu_tilde
mu_bar_final = mu_bar(:, end);      % Last iteration of mu_bar

% ===== Plot Results (Only Positive Frequencies) =====
% Generate mirrored frequencies from -pi to pi
freqs_mirrored =  [-flip(freqs(2:end)), freqs]; % Exclude zero to avoid duplication

% Mirror the data for symmetric plotting
mu_tilde_mirrored = [flip(mu_tilde_final(2:end)); mu_tilde_final];  
mu_bar_mirrored = [flip(mu_bar_final(2:end)); mu_bar_final];  
mussv_lower_mirrored = [flip(mussv_lower_values(2:end)); mussv_lower_values];

% Plot results
figure;
hold on;
set(gca,'Box','on')

%grid on;
% xlabel('Frequency (rad/s)', 'Interpreter', 'latex');
% ylabel('Structured Singular Value ($\mu$)', 'Interpreter', 'latex');
% title(sprintf('Structured Singular Value (Case 4), $N = %d$', N), 'Interpreter', 'latex');

% Plot Power Method Results with symmetry
plot(freqs_mirrored, mu_tilde_mirrored, 'b-', 'LineWidth', 0.2, 'DisplayName', '$\tilde{\mu}$');
plot(freqs_mirrored, mu_bar_mirrored, 'g-', 'LineWidth', 0.2, 'DisplayName', '$\bar{\mu}$');

% Plot MUSSV Lower Bound with symmetry
plot(freqs_mirrored, mussv_lower_mirrored, 'r:', 'LineWidth', 1, 'DisplayName', 'MUSSV');
% Set legend with LaTeX
lgd = legend('show', 'Location', 'best');
set(lgd, 'Interpreter', 'latex', 'FontSize', 11);

yline(max_mussv_value, 'k:', 'LineWidth', 0.5, 'HandleVisibility', 'off'); % Horizontal line
xline(max_mussv_freq, 'k:', 'LineWidth', 0.5, 'HandleVisibility', 'off');  % Vertical line at positive peak frequency
xline(-max_mussv_freq, 'k:', 'LineWidth', 0.5, 'HandleVisibility', 'off'); % Vertical line at negative peak frequency

xlabel('$\omega$ (rad/s)', 'Interpreter', 'latex', 'FontSize', 10);
%ylabel('$\mu_{\Delta}(G_0)$', 'Interpreter', 'latex', 'FontSize', 10);
ylabel('$\mu_{\Delta}^{\prime} (G_0(e^{i\omega}))$', 'Interpreter', 'latex', 'FontSize', 10);
set(gca, 'FontSize', 10);



xlim([-pi+0.005, pi-0.005]); % Ensure x-axis is from -pi to pi

hold off;
print('-depsc2', 'mu_plot2.eps');